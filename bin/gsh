#!/usr/bin/env python
#
# Name: 		Global SSH Client
# Description:	help connect ssh between client behind NAT.
#				ssh use paramiko
# project 2
#
# Author: 		Nguyen Thanh Hiep - Nguyen Huu Dinh
# Time: 		2014/10
# Requirements: paramiko, ecdsa
#

import os, sys, getpass
from optparse 	import OptionParser
from optparse 	import OptionGroup
from gsh 		import Request, __version__
request = Request()
def Main():
	parser = OptionParser(description='global ssh help connect ssh behind NAT',
                                   prog='gsh',
                                   version=__version__,
                                   usage='%prog [user@][hostname-mac] [options]')
	group = OptionGroup(parser, "account")
	group.add_option("-L", "--login", action ='store_true', default=False,
        help="login to server")
	group.add_option("-R", "--register", action ='store_true', default=False, 
		help="register new account")
	group.add_option("--logout", action ='store_true', default=False, 
		help="logout account")
	parser.add_option_group(group)

	group = OptionGroup(parser, "connect")	#create group of parser
	group.add_option("--connect", metavar="HOSTNAME",
        help="-c [user@]hostname or mac") # add option parser
	group.add_option("-s", "--service", metavar="*", default="ssh",
        help="[user@]hostname -s service_command") # add option parser
	group.add_option("-p", "--port", type="int", metavar="*",
        help="[user@]hostname -p port") # add option parser
	group.add_option("-c", "--command", metavar="*",
        help="[user@]hostname -c command") # add option parser
	group.add_option("-i", "--identity", metavar="*",
        help="[user@]hostname -i identity_file") # add option parser
	group.add_option("-v", "--verbose", action ='store_true', default=False,
        help="[user@]hostname -v debugging mode") # add option parser
	group.add_option("--cnet", metavar="*",
        help="[netname] create network")
	group.add_option("-n", "--net", metavar="*",
        help="-n [netname] add network")
	group.add_option("-r", "--rnet", metavar="*",
        help="-r [netname] remove network")
	parser.add_option_group(group)

	group = OptionGroup(parser, "infomation")
	group.add_option("-l", "--list", action ='store_true', default=False,
        help="show peer online")
	group.add_option("-g", "--logs", action ='store_true', default=False,
        help="show logs")
	parser.add_option_group(group)

	options, args = parser.parse_args()
	processparser(options, args)
def superuser():
	if os.geteuid() != 0:
		args = ['sudo', sys.executable] + sys.argv + [os.environ]
		# the next line replaces the currently-running process with the sudo
		os.execlpe('sudo', *args)

def processparser(options, args):

	if options.verbose:
		request.setverbose()
	if options.register:
		if len(args) == 0:
			user = raw_input("* USERNAME: ")	
			pswd = getpass.getpass('* PASSWORD for %s:' % user)
			repswd = getpass.getpass('* CONFIRM PASSWORD: ')
			if pswd != repswd:
				print '* ERROR: confirm password not match!'
				return
		elif len(args) == 1:
			user = args[0]
			pswd = getpass.getpass('* PASSWORD for %s:' % user)
			repswd = getpass.getpass('* CONFIRM PASSWORD: ')
			if pswd != repswd:
				print '* ERROR: confirm password not match!'
				return
		else:
			user = args[0]
			pswd = args[1]
		request.register(user, pswd)
		return

	if options.login:
		superuser()
		if len(args) == 0:
			user = raw_input("* USERNAME: ")	
			pswd = getpass.getpass('* PASSWORD for %s:' % user)
		elif len(args) == 1:
			user = args[0]
			pswd = getpass.getpass('* PASSWORD for %s:' % user)
		else:
			user = args[0]
			pswd = args[1]
		request.login(user, pswd)
		return
	if options.logout:
		superuser()
		request.logout()

	if options.connect is not None:		
		request.connect(options.connect, options, args)
		return
	if options.net is not None:
		request.addnetwork(options.net)
		return
	if options.cnet is not None:
		request.createnetwork(options.cnet)
		return
	if options.rnet is not None:
		request.renetwork(options.rnet)
		return
	if options.list:
		request.listmachine()
		return
	if options.logs:
		request.logs()
		return
	if len(args) == 0:
		request.listmachine()
	if len(args) >= 1:
		request.connect(args[0], options, args)
if __name__ == "__main__":
	Main()